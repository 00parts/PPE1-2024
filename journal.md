# Journal de bord du projet encadré


## Séance du 25/09/24 et exercice

Durant cette première séance, nous nous sommes familiarisés avec le terminal de commandes sous Linux. Pour cela, nous avons effectué plusieurs commandes pour naviguer au sein du système de fichiers au sein du shell. Nous avons appris comment l'arborescence de fichiers est organisée dans un ordinateur. / désigne le root, ~/ désigne le dossier personnel (ou home)./ désigne le dossier actuel dans lequel nous nous trouvons (working directory), ../ désigne le dossier parent au dossier dans lequel on se trouve. On peut soit écrire un chemin absolu qui retrace l'arborescence entière de la racine jusqu'au fichier concerné, ou bien un chemin relatif qui décrit le chemin jusqu'au fichier par rapport au dossier où on se trouve. On peut utiliser des wildcards pour remplacer un caractère (?) ou plusieurs (*) quand on écrit un nom de fichier. Cela peut permettre par exemple de déplacer plusieurs fichiers d'un coup -> si on fait mv *.txt /txt on déplace tous les fichiers qui ont pour extension .txt dans un dossier txt.

Voici quelques commandes que nous avons appris : cd -> change directory, permet de changer le dossier courant. mv -> move, permet de déplacer un ou des fichiers dans un dossier donné. rm -> remove, permet de supprimer un fichier donné. mkdir -> make directory, permet de créer un dossier. ls -> list, permet de lister le contenu d'un dossier. unzip -> permet de décompresser un dossier compressé de type zip. Et pleins d'autres encore.

Notre premier exercice a été de réorganiser l'arborescence d'un dossier archivé qui nous a été fourni. Nous devions le décompresser, puis créer des dossiers au sein de celui-ci pour trier les fichiers par type, puis par date (année et mois), ainsi que villes. Je n'ai pas eu de difficulté sur cette exercice, si ce n'est une erreur bête de ma part : je voulais déplacer des images contenant le mot "paris" dans le nom de fichier dans un dossier nommé Paris, mais je ne comprenais pas pourquoi ça ne fonctionnait pas. J'avais écrit : mv Paris.* /img. /img était le dossier d'images dans lequel je me trouvais, le dossier courant, et non pas le dossier de destination qui était /Paris. Je croyais m'être trompée dans l'utilisation des wildcards alors que j'essayais sans m'en être rendue compte de déplacer des fichiers dans un dossier dans lequel ils se trouvaient déjà. Une fois cette erreur corrigée, j'ai fait attention et je n'ai plus eu de soucis. Au tout début j'ai eu un peu de mal avec les chemins relatifs (notamment l'utilisation de ../) mais avec la pratique et grâce à l'exercice j'ai vite compris. A la fin, en voulant zipper mon dossier final via le terminal et la commande zip, j'ai eu une erreur de buffer overflow. J'ai cru que j'avais mal tapé la commande mais ce n'était pas le cas, j'étais dans le bon dossier et je travaillais sur le bon dossier. J'ai donc dû malheureusement zipper le dossier via le GUI.

## Séance du 02/10/24 et exercice

Pendant cette séance nous avons commencé à nous familiariser avec git, qui est un système de gestion de version. N'ayant jamais fait usage de github auparavant, à part pour télécharger des logiciels ou applications sur des dépôts, j'ai eu un peu de mal à comprendre le fonctionnement, c'était un peu abstrait. Mais j'ai quand même suivi sans trop de difficulté les manipulations afin de créer la clé SSH et pour le clonage du dépôt des professeurs.
A la maison, nous devions créer notre propre dépôt git et le synchroniser avec notre machine. J'avais déjà créé un dépôt pour mon journal, mais j'en ai donc créé un nouveau qui soit dédié au PPE entier, pas qu'au journal. J'ai créé le dépôt puis j'ai ouvert un terminal à l'emplacement de mon cours de PPE sur ma machine. J'ai tenté de cloner mon dépôt via le terminal mais j'avais oublié une chose : il y avait déjà le dossier des professeurs qui porte le même nom que mon dépôt. J'ai dû donc créer un sous-dossier, m'y déplacer et retenter le clonage qui cette fois-ci a fonctionné. J'ai pu vérifier cela avec une commande git status. J'ai ensuite créé le fichier markdown du journal sur github, puis j'ai effectué une commande git log sur mon terminal et j'ai vu que le dernier commit recensé était celui de la création du dépôt, prouvant bien que ma machine n'était pas encore synchronisé avec la version en ligne. J'ai donc fait un git pull et j'ai récupéré le fichier journal.md sur ma machine. En refaisant un git log, j'ai pu voir effectivement le nouveau commit de l'ajout du journal de bord. Ensuite, j'ai modifié ce journal comme je suis en train de le faire en ce moment pour ajouter des modifications. J'en ai profité pour ajouter ce que j'avais déjà écrit dans mon ancien journal de bord pour la séance de la semaine dernière. Je m'apprête maintenant à effectuer un git status pour vérifier que git a détecté que ce fichier a été modifié, puis je ferais un git add et git commit afin de valider ces modifications et un git push afin de synchroniser le fichier nouvellement modifié avec le dépôt en ligne.

## Séance du 09/10/24 et exercice

 Lors de cette séance nous avons abordé les moyens pour annuler/corriger des erreurs sur git. Il y a plusieurs méthodes : `revert`, qui permet de créer un nouveau commit qui va défaire un commit en particulier (le nouveau commit va supprimer ce qui a été ajouté et rajouter ce qui a été supprimé). `reset` : permet d'annuler un ou plusieurs commits de façon linéaire. (c'est à dire qu'on ne peut pas sélectionner un commit particulier à enlever). Il y a plusieurs paramètres pour cette commande : `git reset HEAD~` permet d'annuler tous les commits qui n'ont pas été poussés et de retourner à la version d'origine du dépôt (là où se trouve origin/HEAD). Cela annule également le staging, c'est-à-dire qu'il faudra add de nouveau les fichiers concernés pour pouvoir les commit. `git reset --soft HEAD~` fait la même chose sans annuler le staging, donc pas besoin de refaire add. C'est utile si par exemple on a oublié d'ajouter un fichier pour un même commit : au lieu de tout remettre un par un, on a juste à soft reset et add le fichier manquant puis commit de nouveau. `git reset --hard` annule tous les commits jusqu'à origin/HEAD et supprime tous les changements en local. Par exemple, si je crée un fichier foo.txt, que je l'add, que je le commit, puis que je fais git reset --hard, non seulement le commit et le staging seront annulés mais le fichier sera supprimé du dépôt local et donc perdu.
 Par ailleurs on n'est pas obligé de reset jusqu'à origin/HEAD, on peut indiquer l'identifiant SHA d'un commit et cela va donc annuler non pas juste ce commit, mais tous les commits jusqu'à ce commit. Idem avec un tag. Ainsi revert est un processus additif : on crée un commit qui "inverse" les changements d'un commit en particulier; reset est destructif : il annule tout jusqu'à un certain point.
 On a ensuite vu que pour pouvoir ajouter des modifications sur le dépôt en ligne, il faut que notre dépôt soit à jour : autrement dit, nos push seront refusés si notre dépôt local est en retard sur le dépôt distant. Pour cela il faut git pull : mais si par exemple il y a un même fichier en local et en ligne qui avec des modifications différentes, cela créé un conflit. Il faut donc mettre de côté les modifications locales pour pouvoir pull et ensuite éventuellement rajouter les modifications qu'on a mises de côté pour pouvoir les push. Nous avons donc appris une commande qui permet de mettre de côté des modifications : `git stash push`. Effectuer cette commande permet de placer nos modifications en cours dans un index qu'on peut visualiser avec `git stash list` où chaque paquet de modification a son propre indice. `git stash show <stash>` permet de voir le contenu du stash à l'indice indiqué. Enfin, `git stash apply` et `git stash pop` permettent d'appliquer les changements d'un stash : apply les applique tout en conservant le stash, et pop applique les modifications puis supprime le stash. Ainsi admettons qu'on a un fichier foo.txt, modifié en distant d'une certaine manière, et sur lequel on a travaillé en local en parallèle avec d'autres modifications. On ne peut ni push car pas à jour avec le local distant ni pull car les fichiers sont en conflit. On doit d'abord add le fichier concerné donc `git add foo.txt` puis `git stash -m "message quelconque"`. Cela va supprimer nos modifications du dépôt local mais en les conservant au sein du stash. On peut ensuite git pull et récupérer le fichier foo.txt telle qu'il apparaît dans le dépôt distant puis on peut faire `git stash apply 0` ou `git stash pop 0` afin de "réimplémenter" nos modifications dans le fichier. On peut ensuite push nos nouvelles modifications.

 En ce qui concerne les exercices à faire à la maison, nous avions d'abord des exercices sur les pipelines. Pour être honnête, j'ai eu du mal avec cet exercice. Le début, les parties 1A et 1B étaient simples, mais pour l'exercice 2, je m'y suis mis avec deux autres camarades pour essayer de trouver comment utiliser les nouvelles commandes de l'exercice. Ce n'était pas tant avec le principe des pipelines que j'avais du mal, car j'ai compris le principe, mais plus avec l'exécution de l'exercice. Pour que tout tienne sur une ligne, il y avait beaucoup de commandes à mettre dans le bon ordre avec les bonnes options. Pour mieux s'y retrouver nous avons réfléchi en partant du résultat final : ce qui doit être affiché, et nous nous sommes demandés quelle commande permet d'effectuer quoi et dans quel ordre cela doit se faire. On a donc fait un schéma sur un papier pour mieux visualiser l'ordre des choses. Faire ça a beaucoup aidé à comprendre le résultat qu'on devait avoir. Mais nous avions quand même encore du mal à trouver les bonnes options et l'ordre de certains commandes. Avec un peu de trial and error, on a fini par trouver. Notre commande consistait donc à d'abord concaténer tous les fichiers ann de tous les sous-dossiers du dossier 2016, puis de faire un egrep "Location" pour n'en retenir que les annotations de lieux. Ensuite on "coupe" les lignes du fichier pour ne garder que les noms de lieux en faisant `cut -f 3` : -f signifie qu'on prend la tabulation comme délimiteur et le 3 indique qu'on ne garde que le 3ème champ de la ligne. Ensuite on met `sort -d`, qui va mettre tous les noms de lieux dans l'ordre alphabétique. Ensuite on met `uniq -c`. Cette commande va prendre toutes les lignes qui apparaissent à l'identique plusieurs fois, ne garder qu'une occurence, mais mettre à gauche le nombre total d'occurences. Par exemple si on a :
 Lyon
 Lyon
 Lyon
 alors la commande uniq -c va garder le premier Lyon et mettre un 3 à côté qui correspond au nombre total d'occurences, comme ceci :
 3 Lyon
 Ensuite, on remet une commande sort mais cette fois ci avec l'option -n, qui permet de trier les nombres par ordre croissant. Enfin, pour pouvoir garder uniquement que les 15 dernières lignes (celles avec le plus grand nombre d'occurences donc) on fait `tail -n 15`. L'option -n permet d'indiquer un nombre N de lignes, ici 15.
 Une fois qu'on a trouvé cette pipeline, le reste de l'exercice a été fait rapidement.

### Exercices git correction d'erreurs

Cette ligne doit rester après correction.
