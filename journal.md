# Journal de bord du projet encadré


## Séance du 25/09/24 et exercice

Durant cette première séance, nous nous sommes familiarisés avec le terminal de commandes sous Linux. Pour cela, nous avons effectué plusieurs commandes pour naviguer au sein du système de fichiers au sein du shell. Nous avons appris comment l'arborescence de fichiers est organisée dans un ordinateur. / désigne le root, ~/ désigne le dossier personnel (ou home)./ désigne le dossier actuel dans lequel nous nous trouvons (working directory), ../ désigne le dossier parent au dossier dans lequel on se trouve. On peut soit écrire un chemin absolu qui retrace l'arborescence entière de la racine jusqu'au fichier concerné, ou bien un chemin relatif qui décrit le chemin jusqu'au fichier par rapport au dossier où on se trouve. On peut utiliser des wildcards pour remplacer un caractère (?) ou plusieurs (*) quand on écrit un nom de fichier. Cela peut permettre par exemple de déplacer plusieurs fichiers d'un coup -> si on fait mv *.txt /txt on déplace tous les fichiers qui ont pour extension .txt dans un dossier txt.

Voici quelques commandes que nous avons appris : cd -> change directory, permet de changer le dossier courant. mv -> move, permet de déplacer un ou des fichiers dans un dossier donné. rm -> remove, permet de supprimer un fichier donné. mkdir -> make directory, permet de créer un dossier. ls -> list, permet de lister le contenu d'un dossier. unzip -> permet de décompresser un dossier compressé de type zip. Et pleins d'autres encore.

Notre premier exercice a été de réorganiser l'arborescence d'un dossier archivé qui nous a été fourni. Nous devions le décompresser, puis créer des dossiers au sein de celui-ci pour trier les fichiers par type, puis par date (année et mois), ainsi que villes. Je n'ai pas eu de difficulté sur cette exercice, si ce n'est une erreur bête de ma part : je voulais déplacer des images contenant le mot "paris" dans le nom de fichier dans un dossier nommé Paris, mais je ne comprenais pas pourquoi ça ne fonctionnait pas. J'avais écrit : mv Paris.* /img. /img était le dossier d'images dans lequel je me trouvais, le dossier courant, et non pas le dossier de destination qui était /Paris. Je croyais m'être trompée dans l'utilisation des wildcards alors que j'essayais sans m'en être rendue compte de déplacer des fichiers dans un dossier dans lequel ils se trouvaient déjà. Une fois cette erreur corrigée, j'ai fait attention et je n'ai plus eu de soucis. Au tout début j'ai eu un peu de mal avec les chemins relatifs (notamment l'utilisation de ../) mais avec la pratique et grâce à l'exercice j'ai vite compris. A la fin, en voulant zipper mon dossier final via le terminal et la commande zip, j'ai eu une erreur de buffer overflow. J'ai cru que j'avais mal tapé la commande mais ce n'était pas le cas, j'étais dans le bon dossier et je travaillais sur le bon dossier. J'ai donc dû malheureusement zipper le dossier via le GUI.

## Séance du 02/10/24 et exercice

Pendant cette séance nous avons commencé à nous familiariser avec git, qui est un système de gestion de version. N'ayant jamais fait usage de github auparavant, à part pour télécharger des logiciels ou applications sur des dépôts, j'ai eu un peu de mal à comprendre le fonctionnement, c'était un peu abstrait. Mais j'ai quand même suivi sans trop de difficulté les manipulations afin de créer la clé SSH et pour le clonage du dépôt des professeurs.
A la maison, nous devions créer notre propre dépôt git et le synchroniser avec notre machine. J'avais déjà créé un dépôt pour mon journal, mais j'en ai donc créé un nouveau qui soit dédié au PPE entier, pas qu'au journal. J'ai créé le dépôt puis j'ai ouvert un terminal à l'emplacement de mon cours de PPE sur ma machine. J'ai tenté de cloner mon dépôt via le terminal mais j'avais oublié une chose : il y avait déjà le dossier des professeurs qui porte le même nom que mon dépôt. J'ai dû donc créer un sous-dossier, m'y déplacer et retenter le clonage qui cette fois-ci a fonctionné. J'ai pu vérifier cela avec une commande git status. J'ai ensuite créé le fichier markdown du journal sur github, puis j'ai effectué une commande git log sur mon terminal et j'ai vu que le dernier commit recensé était celui de la création du dépôt, prouvant bien que ma machine n'était pas encore synchronisé avec la version en ligne. J'ai donc fait un git pull et j'ai récupéré le fichier journal.md sur ma machine. En refaisant un git log, j'ai pu voir effectivement le nouveau commit de l'ajout du journal de bord. Ensuite, j'ai modifié ce journal comme je suis en train de le faire en ce moment pour ajouter des modifications. J'en ai profité pour ajouter ce que j'avais déjà écrit dans mon ancien journal de bord pour la séance de la semaine dernière. Je m'apprête maintenant à effectuer un git status pour vérifier que git a détecté que ce fichier a été modifié, puis je ferais un git add et git commit afin de valider ces modifications et un git push afin de synchroniser le fichier nouvellement modifié avec le dépôt en ligne.

## Séance du 09/10/24 et exercice

 Lors de cette séance nous avons abordé les moyens pour annuler/corriger des erreurs sur git. Il y a plusieurs méthodes : `revert`, qui permet de créer un nouveau commit qui va défaire un commit en particulier (le nouveau commit va supprimer ce qui a été ajouté et rajouter ce qui a été supprimé). `reset` : permet d'annuler un ou plusieurs commits de façon linéaire. (c'est à dire qu'on ne peut pas sélectionner un commit particulier à enlever). Il y a plusieurs paramètres pour cette commande : `git reset HEAD~` permet d'annuler tous les commits qui n'ont pas été poussés et de retourner à la version d'origine du dépôt (là où se trouve origin/HEAD). Cela annule également le staging, c'est-à-dire qu'il faudra add de nouveau les fichiers concernés pour pouvoir les commit. `git reset --soft HEAD~` fait la même chose sans annuler le staging, donc pas besoin de refaire add. C'est utile si par exemple on a oublié d'ajouter un fichier pour un même commit : au lieu de tout remettre un par un, on a juste à soft reset et add le fichier manquant puis commit de nouveau. `git reset --hard` annule tous les commits jusqu'à origin/HEAD et supprime tous les changements en local. Par exemple, si je crée un fichier foo.txt, que je l'add, que je le commit, puis que je fais git reset --hard, non seulement le commit et le staging seront annulés mais le fichier sera supprimé du dépôt local et donc perdu.
 Par ailleurs on n'est pas obligé de reset jusqu'à origin/HEAD, on peut indiquer l'identifiant SHA d'un commit et cela va donc annuler non pas juste ce commit, mais tous les commits jusqu'à ce commit. Idem avec un tag. Ainsi revert est un processus additif : on crée un commit qui "inverse" les changements d'un commit en particulier; reset est destructif : il annule tout jusqu'à un certain point.
 On a ensuite vu que pour pouvoir ajouter des modifications sur le dépôt en ligne, il faut que notre dépôt soit à jour : autrement dit, nos push seront refusés si notre dépôt local est en retard sur le dépôt distant. Pour cela il faut git pull : mais si par exemple il y a un même fichier en local et en ligne qui avec des modifications différentes, cela créé un conflit. Il faut donc mettre de côté les modifications locales pour pouvoir pull et ensuite éventuellement rajouter les modifications qu'on a mises de côté pour pouvoir les push. Nous avons donc appris une commande qui permet de mettre de côté des modifications : `git stash push`. Effectuer cette commande permet de placer nos modifications en cours dans un index qu'on peut visualiser avec `git stash list` où chaque paquet de modification a son propre indice. `git stash show <stash>` permet de voir le contenu du stash à l'indice indiqué. Enfin, `git stash apply` et `git stash pop` permettent d'appliquer les changements d'un stash : apply les applique tout en conservant le stash, et pop applique les modifications puis supprime le stash. Ainsi admettons qu'on a un fichier foo.txt, modifié en distant d'une certaine manière, et sur lequel on a travaillé en local en parallèle avec d'autres modifications. On ne peut ni push car pas à jour avec le local distant ni pull car les fichiers sont en conflit. On doit d'abord add le fichier concerné donc `git add foo.txt` puis `git stash -m "message quelconque"`. Cela va supprimer nos modifications du dépôt local mais en les conservant au sein du stash. On peut ensuite git pull et récupérer le fichier foo.txt telle qu'il apparaît dans le dépôt distant puis on peut faire `git stash apply 0` ou `git stash pop 0` afin de "réimplémenter" nos modifications dans le fichier. On peut ensuite push nos nouvelles modifications.

 En ce qui concerne les exercices à faire à la maison, nous avions d'abord des exercices sur les pipelines. Pour être honnête, j'ai eu du mal avec cet exercice. Le début, les parties 1A et 1B étaient simples, mais pour l'exercice 2, je m'y suis mis avec deux autres camarades pour essayer de trouver comment utiliser les nouvelles commandes de l'exercice. Ce n'était pas tant avec le principe des pipelines que j'avais du mal, car j'ai compris le principe, mais plus avec l'exécution de l'exercice. Pour que tout tienne sur une ligne, il y avait beaucoup de commandes à mettre dans le bon ordre avec les bonnes options. Pour mieux s'y retrouver nous avons réfléchi en partant du résultat final : ce qui doit être affiché, et nous nous sommes demandés quelle commande permet d'effectuer quoi et dans quel ordre cela doit se faire. On a donc fait un schéma sur un papier pour mieux visualiser l'ordre des choses. Faire ça a beaucoup aidé à comprendre le résultat qu'on devait avoir. Mais nous avions quand même encore du mal à trouver les bonnes options et l'ordre de certains commandes. Avec un peu de trial and error, on a fini par trouver. Notre commande consistait donc à d'abord concaténer tous les fichiers ann de tous les sous-dossiers du dossier 2016, puis de faire un egrep "Location" pour n'en retenir que les annotations de lieux. Ensuite on "coupe" les lignes du fichier pour ne garder que les noms de lieux en faisant `cut -f 3` : -f signifie qu'on prend la tabulation comme délimiteur et le 3 indique qu'on ne garde que le 3ème champ de la ligne. Ensuite on met `sort -d`, qui va mettre tous les noms de lieux dans l'ordre alphabétique. Ensuite on met `uniq -c`. Cette commande va prendre toutes les lignes qui apparaissent à l'identique plusieurs fois, ne garder qu'une occurence, mais mettre à gauche le nombre total d'occurences. Par exemple si on a :
 Lyon
 Lyon
 Lyon
 alors la commande uniq -c va garder le premier Lyon et mettre un 3 à côté qui correspond au nombre total d'occurences, comme ceci :
 3 Lyon
 Ensuite, on remet une commande sort mais cette fois ci avec l'option -n, qui permet de trier les nombres par ordre croissant. Enfin, pour pouvoir garder uniquement que les 15 dernières lignes (celles avec le plus grand nombre d'occurences donc) on fait `tail -n 15`. L'option -n permet d'indiquer un nombre N de lignes, ici 15.
 Une fois qu'on a trouvé cette pipeline, le reste de l'exercice a été fait rapidement.

### Exercices git correction d'erreurs

Cette ligne doit rester après correction.

Cette ligne est mise de côté


J'écris ceci après avoir fini les exercices de la séance 3, donc après avoir push le dernier tag git-seance3-fin. Je n'ai pas eu de difficulté avec cet exercice, même si ça m'a pris du temps. J'ai fait attention à chaque étape et je n'ai rencontré aucun problème. Tout d'abord il fallait utiliser `git revert` pour défaire un commit poussé qui contenait un lorem ipsum dans le journal de bord, et qui se trouvait parmi d'autres commits poussés qu'il fallait conserver. Il a suffit de faire git revert avec l'identifiant SHA du commit avec l'erreur. Cela créé un nouveau commit qui inverse les changements, et supprime donc les lignes du lorem ipsum.
Ensuite, il fallait défaire des commits qui n'ont pas été poussés. Avant d'attaquer cette exercice je me suis entraîné sur le dépôt privé que nous avons créé pour faire des tests. J'ai ensuite créé le fichier oups.md. J'ai fait un commit pour la création du fichier, puis j'ai ajouté une section parlant du cours de la séance 3, que j'ai commit, puis j'ai ajouté une section parlant des exercices de pipeline, que j'ai commit également. J'avais donc 3 commits sur le "mauvais" fichier. J'ai bien pris la peine de ne rien push. J'ai ensuite fait un `git reset` jusqu'au tag "git-seance3-defaire". Ce git reset a défait tous les commits jusqu'au tag, et a enlevé le fichier oups.md du staging. J'ai ensuite copié ce que j'avais écrit sur oups.md et je l'ai collé dans le journal. Puis j'ai supprimé oups.md avec rm. J'ai ensuite add et commit les changements et je les ai poussés.
Enfin, le dernier exercice portait sur la commande stash et les conflits. Encore une fois, j'ai bien lu les consignes avant de commencer, et j'ai également testé de faire cela dans le dépôt d'essai. J'ai ensuite modifié le fichier en ligne, en ajoutant la ligne "corrections d'erreurs", puis j'ai commit ce changement. Puis j'ai ajouté en local une autre ligne à la fin qui sera mise de côté. J'ai ensuite voulu directement regarder via `git status` que j'étais bien en retard par rapport à la version en ligne : mais j'avais oublié de `git fetch`, donc ça indiquait que j'étais à jour. Je m'en suis vite rendu compte et j'ai git fetch pour mettre à jour les métadonnées avant de retenter un git status qui cette fois ci m'a bien indiqué que j'étais en retard d'1 commit. J'ai tenté de pull, mais comme prévu, cela n'a pas fonctionné. J'ai donc effectué un `git stash push -m "Conservation des changements séance 3"` ce qui a enlevé mes modifications en local tout en les conservant dans le stash. Ensuite j'ai fait `git stash list` pour voir que j'avais bien un stash, puis j'ai fait `git stash show -p 0` pour voir le contenu du stash, c'est-à-dire les modifications qu'il contient. Ensuite j'ai refait `git pull` qui cette fois a fonctionné, j'ai donc récupéré les changements que j'avais fait en ligne. J'ai refait git status pour voir que j'étais bien à jour. Ensuite, j'ai fait `git stash pop 0` ce qui a appliqué les modifications du stash que j'avais créé tout en supprimant le stash après coup. J'ai vérifié que mon fichier contenait bien aussi bien les changements que j'avais fait en ligne et les changements en local qui venaient d'être appliqués, ce qui était le cas, puis j'ai git add et git commit. J'ai créé le tag pour indiquer la fin de l'exercice avec le message et j'ai poussé ce tag ainsi que le tag "git-seance3-defaire" que je n'avais pas encore push. J'ai finalement push le commit.


## Séance du 16/10/24 et exercice

Durant cette séance nous avons vu comment faire des scripts bash. Je n'ai pas eu trop de mal à suivre ce cours et à le comprendre car en soi c'est la même chose que nous avons fait sur bash : mais au lieu que ce soit dans le terminal c'est dans un fichier. La syntaxe pour les boucles for et while, les tests "if" etc, n'était pas dure à comprendre puisque c'est un peu comme dans python, juste écrit différemment.

### Exercices scripts

Pour la réalisation de ces scripts je n'ai pas trop eu de mal. J'ai eu deux "difficultés" qui sont plus des erreurs d'attention plutôt que des difficultés car j'ai pu les corriger rapidement :
Tout d'abord, ma première erreur concernait l'utilisation de la wildcard. En effet, dans un des scripts, on devait pouvoir utiliser la wildcard comme argument pour les chemins de fichier. Sauf qu'au moment de rentrer * en tant qu'argument dans le terminal, ça ne fonctionnait pas, j'avais des erreurs concernant des fichiers qui se trouvaient au sein du dépôt git et non pas dans le dossier où se trouve les annotations. Après un peu de recherche sur google, j'ai trouvé qu'il suffisait simplement de mettre des guillemets autour de l'astérisque quand on l'emploie comme argument : comme ceci "*". Et en effet, cela m'a fait me rendre compte que le fait d'écrire la wildcard en tant qu'argument directement dans le terminal fait que bash interprète la wildcare directement, pour le dossier courant qui est celui du dépôt git puisque j'exécute le script à partir de ce dossier. En mettant des guillemets, j'imagine que c'est considéré comme un string, qui, en remplaçant la variable auquel il est associé, va être interprété comme une wildcard à ce moment-là. Une fois que j'ai corrigé cela, tout fonctionnait parfaitement.
Le deuxième soucis que j'ai rencontré est tout simplement une erreur dans une de mes boucles. J'ai voulu créer une boucle pour tester l'existence de tous les fichiers dans un dossier donné, puisque -f ne fonctionne pas avec une wildcard, ça dit qu'il y a trop d'arguments. Du coup, j'ai créé une boucle qui parcourt tous les fichiers du dossier et teste leur existence une par une avec `test`. Mon erreur était que je n'ai pas fermé la boucle assez tôt : j'ai mis le done après avoir mis `echo`, `cat | egrep | wc` ce qui fait que quand j'ai lancé le script, j'ai eu des dizaines et des dizaines de lignes qui défilaient. Je me suis vite rendue compte que c'était parce qu'avec la manière dont j'ai écrit la boucle, il effectuait echo + affichait le résultat de wc pour chacun des fichiers qu'il parcourait. J'ai donc juste mis done directement après le `test -f` et tout est rentré dans l'ordre.


### Explication du code de la slide

Tout d'abord, on a en premier un shebang avec #!/usr/bin/bash. Cela permet d'expliciter à l'ordinateur l'interpréteur qui doit être utilisé. Cela permet de rendre le script directement exécutable si on fait chmod +x.

Ensuite, on a un test `if [ $# -ne 1 ]` Ce test permet de vérifier qu'un seul argument a été donné grâce à `-ne 1`. $# correspond au nombre total d'arguments écrits dans le terminal. `-ne 1` signifie "n'est pas égal à 1". Autrement dit, ce test fait que si le nombre total d'arguments n'est pas égal à 1, alors le script est arrêté avec un message "Ce programme demande un argument".

FICHIER_URLS=$1 renomme l'argument $1 en une variable FICHIER_URLS.
Ensuite deux autres variables OK et NOK sont déclarés avec une valeur assignée de 0.
Ensuite nous avons une boucle `while`. Cette boucle est suivie d'une commande `read -r line`. Cette commande permet de lire chaque ligne du fichier donné en argument. L'option -r permet d'ignorer le comportement des backslask \ qui normalement permettent de "casser" une longue ligne en deux pour la reconstruire après. Avec -r, même s'il y a un backslash pour séparer une longue ligne en deux, ça va être compté comme deux lignes. La ligne lu va ensuite être stocké dans la variable LINE.
Cette boucle, à chaque fois qu'elle va lire une ligne, va afficher "la ligne : $LINE" autrement dit elle affiche "la ligne" suivi du contenu de la ligne.
Ensuite un test vérifie à l'aide d'une expression régulière si le début de la ligne est "https?://" ou "http://" (le "?" indique la présence ou l'absence du caractère derrière, ici "s"). Le caractère ^ correspond au début de la chaîne de caractère. Si le test est vérifié, alors "ressemble à une url valide" sera affiché et on assigne à la variable OK sa propre valeur + 1 (autrement dit on compte le nombre d'URL valide).
Sinon, on affiche "ne ressemble pas à une url valide" et c'est la variable NOK dont on modifie la valeur.

Je ne suis pas sûre de la signification de `< $FICHIER_URLS` après done, mais je pense que c'est peut-être pour indiquer à la boucle while de continuer à prendre le fichier de l'argument $1 (autrement dit $FICHIER_URLS) en stdin à chaque tour de boucle.

Enfin on affiche le contenu de la variable OK et NOK dans une chaîne de caractères qui indique le nombre d'URLS correctes et le nombre de lignes douteuses.

